# Property Verification using Kontrol

## Add new code

Open the `Counter.sol` file located at `kontrolexample/src/Counter.sol`. The generated contract `Counter` has a public value named `number` that can be incremented using the method `increment()` , or can be set to a specific value using `setNumber(uint256)` .

Let's modify the code to include a special case in which `setNumber` would not update the `number` value and will throw an error instead.

First, before the Counter contract declaration, declare an error by adding `error CoffeeBreak()`. Then, in the `setNumber()` function, add an argument `inLuck` as a `bool`. Lastly, add an `if` statement to define when a coffee break is allowed. We'll specify that a coffee break is permitted if `newNumber` is `0xC0FFEE` and `inLuck` is `true`. In that case, the function reverts and the number is not updated.

With those changes, `Counter.sol` should look something like this:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

error CoffeeBreak();

contract Counter {
   uint256 public number;

   function setNumber(uint256 newNumber, bool inLuck) public {
       number = newNumber;
       if (newNumber == 0xC0FFEE && inLuck == true) {
           revert CoffeeBreak();
       }
   }
    
   function increment() public {
        number++;
    }
}
```

Let's look at what we have. The `setNumber` method will update our only storage variable with the passed value, _except_ when `newNumber` is `0xC0FFEE` **and** the `bool` variable is `true`.

Now let’s write a test for the contract in `kontrolexample/test/Counter.t.sol`

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Counter.sol";

contract CounterTest is Test {
   Counter public counter;

   function setUp() public {
       counter = new Counter();
       counter.setNumber(0, false);
   }
   
   function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

   function testSetNumber(uint256 x, bool inLuck) public {
       counter.setNumber(x, inLuck);
       assertEq(counter.number(), x);
   }
}

```

Run the following command to run this test:

```
forge test --match-test testSetNumber
```

This should pass almost every time. Note that the test command will automatically build the project as well. Whether the test passes or not depends on the random inputs generated by `forge`. If `forge` generates the input `x = 0xC0FFEE, inLuck = true`, then the test will fail. Otherwise, it will pass. The point is that there is one case where the property (`setNumber` updates the storage) doesn't hold, but `forge` won't catch it unless it happens to randomly generate this specific input.

Next, we will demonstrate Property Verification using **Kontrol**, and show how it allows us to catch errors like this that `forge` might miss.

Now, `Counter.t.sol` should look like this:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Counter.sol";
import "kontrol-cheatcodes/KontrolCheats.sol";

contract CounterTest is Test, KontrolCheats {
   Counter public counter;

   function setUp() public {
       counter = new Counter();
       counter.setNumber(0, false);
   }

   function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

   function testSetNumber(uint256 x, bool inLuck) public {
       kevm.infiniteGas();
       counter.setNumber(x, inLuck);
       assertEq(counter.number(), x);
   }
}
```

Recall that there's no real need to include the `infiniteGas()` in your code, it's only shown here as an example of how to include Kontrol's cheatcodes. A section on how to use each cheat code will be provided in the future.

Let's build a **KEVM** semantic definition for your Foundry project. Our tool compiles the source and test files with `forge build` under the hood, so there's no need to call it explicitly. After compilation, it inspects the artifacts generated by solc and produces **KEVM** helper modules containing information for each Solidity contract found. Each helper module contains productions and rules for ABI properties and bytecode. If you are curious, you can view the `out/kompiled/foundry.k` file. To get started, run the command below:

```sh
kontrol build
```

{% hint style="warning" %}
The process should take a minute and may emit some warnings, so don’t worry. Also, remember that during the development, you may need to rebuild the definition in various ways.
{% endhint %}

If you change the Solidity code, you must re-run the `kontrol build` command.

For more information about `kontrol build` you can refer to [#kontrol-build](../../cheatsheets/kontrol-cheatsheet.md#kontrol-build "mention") or run:

```
kontrol build --help
```

Once you have built the definition, you can run tests symbolically. In this case remember we are expecting the test to **fail**. The proof should fail after running for about 15 minutes.

{% hint style="info" %}
The time it takes to run can vary depending on the machine. If it appears to be stalling, you can add `--verbose` to see what is happening.
{% endhint %}

To run the tests use the following:

```
kontrol prove --match-test CounterTest.testSetNumber
```

The `--match-test CounterTest.testSetNumber` flag is used to specify that only a single proof should be executed. This is useful when there are multiple tests in a test file. You can find more information on **Kontrol** commands on the [kontrol-cheatsheet.md](../../cheatsheets/kontrol-cheatsheet.md "mention").

Next, we will cover how to investigate **why** the test failed.

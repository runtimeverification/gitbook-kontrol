# Running proofs with linked libraries

A solidity library is a collection of functions that can be called by other contracts.
If you're not familiar with libraries, we strongly recommend checking the [official documentation](https://docs.soliditylang.org/en/latest/contracts.html#libraries)
An important note to mention is that if a library has only internal or private functions then it is considered an embedded library, and it will be deployed together with the contract that uses it.
However, if a library has at least an external or public function, then the generated bytecode of the contract will have a placeholder like `__$30bbc0abd4d6364515865950d3e0d10953$__` as the compiler does not know where the library will be deployed.
Both kontrol and forge will handle this step automatically when running tests that use linked libraries.

Now let's set up a kontrol project and run some proofs!

First, let's set up a new project using `kontrol init`.
Next, we can create a new file under `test/` named `LinkedLibTest.t.sol`, with the following.
```sol

import "forge-std/Test.sol";

library SimpleMath {
    function square(uint256 x) public pure returns (uint256) {
        return x * x;
    }
}

contract LinkedLibTest is Test {
    function testSquare(uint256 n) public {
        uint256 result = SimpleMath.square(n);
        assertEq(result, n * n);
    }
}
```
For this example, we're going to use a library with a single function that computes the square of a number.

Let's have a look at the test to see what happens.
First, we run `kontrol build` to get the proofs ready for execution.
Next, we run `kontrol prove --mt LinkedLibTest.testSquare --verbose`.
We use `--verbose` to quicky identify issues in real time.
The output may seem overwhelming at first, but that's what this tutorial it is here for.

<figure><img src="../../.gitbook/assets/linked_libs_1.png" alt=""><figcaption><p>Verbose output of kontrol prove</p></figcaption></figure>

First, highlighted in blue you can see the live status of the proof.
This shows the time elapsed, the name of the proof, the status of the proof, and a summary of the control flow graph.

Highlighted in yellow you can see the new address at which the linked library is deployed.

Highlighted in green you can see when the KCFG is extended with one or multiple nodes.
The second message, `Extending current KCFG with the following: 3 non-deterministic branches: 3 --> [4,5,6]`, tells us that the prover discovered three possible states to which the execution of node 3 can lead to.

Shortly after seeing these messages, the proof fails with something similar to the screenshot below.

<figure><img src="../../.gitbook/assets/linked_libs_2.png" alt=""><figcaption><p>output of a failing proof</p></figcaption></figure>

Now let's look closer at the 3-way non-deterministic branching we noticed during the proof execution.
We can open the kontrol Terminal User Interface with `kontrol view-kcfg LinkedLibTest.testSquare`.

After we select the node number 3 from the left panel, we should see something like this.

<figure><img src="../../.gitbook/assets/linked_libs_3.png" alt=""><figcaption><p>Kontrol_TUI_0</p></figcaption></figure>

We see in the bottom right corner, that the source map points to the `uint256 result = SimpleMath.square(n);` instruction.

In addition, we can see that the internal rule, marked with `k:` at which the node was `cut` is `#transferFunds CALLER_ID:Int 728815563385977040452943777879061427756277306518 0`.
This is an internal step that the evm-semantics applies during internal calls.
At this point, our intuition tells us that the execution branches when the machine tries to send `0` funds from a symbolic address named CALLER_ID to the `728815563385977040452943777879061427756277306518` address.

<figure><iframe src="https://giphy.com/embed/s239QJIh56sRW" width="480" height="264" style="" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/everyone-remake-rw-s239QJIh56sRW"></a></p></figure>

Why is there a symbolic `CALLER_ID`? after all the call is being made from the LinkedLibTest contract, so the address that calls the library should be the address of the contract?

Let's rerun the proof with `kontrol prove --mt LinkedLibTest.testSquare --verbose --reinit --break-on-calls`.
We already know that the proof is failing, so let's stop the process as soon as the 3-way branch has been detected.

Notice that in the live status of the proof the version has increased to 1.
We can inspect the new KCFG using `kontrol view-kcfg LinkedLibTest.testSquare --version 1`.

<figure><img src="../../.gitbook/assets/linked_libs_4.png" alt=""><figcaption><p>Kontrol_TUI_1</p></figcaption></figure>

In this version we notice two additional notes before the branching actually takes place.
Additionally, we can see that the call to `SimpleMath.square` is made using a `DELEGATECALL` opcode.
This is also confirmed by the offical documentation, that states:

> ... code is reused using the DELEGATECALL (CALLCODE until Homestead) feature of the EVM. This means that if library functions are called, their code is executed in the context of the calling contract, ...

This explains why the simbolic `CALLER_ID`, which is the address used to initialize and call into the test contract, is used to call the linked library function.
The branching takes place because the prover considers every particular case for which the `CALLER_ID` could be one of the addresses present in the network state.

So, what can we do?
We need to determine if the caller to the library could affect the execution of the call.
In our current case, the outcome of the `SimpleMath.square` shouldn't be different depending on who was the initial caller of the test.
At this point, we can introduce new preconditions for `CALLER_ID` using `vm.assume` before the `SimpleMath.square(uint256)` call.

We can either assume that `CALLER_ID` is different than any address present in the `<network>` state.
``` sol
vm.assume(msg.sender != address(64532647442654720331341006915390590852536243434));
vm.assume(msg.sender != address(728815563385977040452943777879061427756277306518));
vm.assume(msg.sender != address(856800046449367729202688009541038160569764461356));
```

or we can assume that `CALLER_ID` is equal to a concrete address.

```sol
vm.assume(msg.sender == address(0xc0ffee));
```

Let's go with the first approach, updating the test function to:
```sol 
function testSquare(uint256 n) public {
    vm.assume(msg.sender != address(64532647442654720331341006915390590852536243434));
    vm.assume(msg.sender != address(728815563385977040452943777879061427756277306518));
    vm.assume(msg.sender != address(856800046449367729202688009541038160569764461356));
    uint256 result = SimpleMath.square(n);
    assertEq(result, n * n);
}
```

Next, we must rebuild the project with `kontrol build --regen --rekompile`.
With this approach, we preserve the previous proof executions.
Now let's run the new test with `kontrol prove --mt LinkedLibTest.testSquare --reinit`.

Aaand, the proof still fails, but we see that there are only 1 pending node and 1 failing node.
It seems that there is one more branch that takes place.

We could inspect the kcfg once more to see how the control flow graph looks like now, but that is not necesarrily needed, as the information we need right now is also present in the final output of kontrol.


<figure><img src="../../.gitbook/assets/linked_libs_5.png" alt=""><figcaption><p>Kontrol_TUI_2</p></figcaption></figure>

The output represents a summary of the first "failure" node from the KCFG.
It has three components: the failure reason, the path condition, and the model.
Highlighted in the ouput we can see that the status code is an EVMC_REVERT,

Let's focus on the path condition for a bit.
We can see that it is a conjunction of two negated conditions:
    1 `.#Not ( { VV0_n_114b9705:Int #Equals chop ( VV0_n_114b9705:Int *Int VV0_n_114b9705:Int ) /Word VV0_n_114b9705:Int } )`
    2. `#Not ( { VV0_n_114b9705:Int #Equals 0 } )`

The second one is pretty straightforward, asserting that the symbolic argument `VV0_n_114b9705`, is non-zero.
For the first one, we can simplify the variable name to obtain `#Not( n #Equals chop (n *Int n /Word n))`.
Let's break it apart:
- `chop()` is an internal function that ensures that it's argument is lower than `2^256`.
Think about it as a (`_%_`) mod operation.
- In the K language, operators also take the sort on which they are applied.
  `*Int` represents the product of two unbounded integers.

The equation above is equivalent to `( n != (n * n / n) mod type(uint256).max)` which looks more like an overflow check.
And that's what it actually represents, it is a compiler inserted check for the operation inside the `square` function.
So, the proof will lead to an overflow that will throw a revert whenever n is not 0 and n is not equal to `((n * n / n) mod type(uint256).max)`.

The model also gives as a counter-example value from `n`, under `VV0_n_114b9705 = pow128`.
In Solidity, to avoid overflow when squarring a number, the result must stay within the `uint256` range, which has a maximum value of `2^256 - 1`.
The largest number you can safely square is `n=2^128 - 1` which is the maximum value for a `uint128` (i.e., `type(uint128).max`).
This comes from the fact that `n^2` must be less than `2^256`. Taking the square root of `2^256` gives `2^128`, meaning any number `>= 2^128` would overflow.

Now, we can avoid this branch by adding a new precondition using

```sol
vm.assume(n <= type(uint128).max);
```

# Property Verification using Kontrol

For this example, we don't need to modify our test to support symbolic execution. However, for more complex use cases, it is possible that some Kontrol cheatcodes are necessary. To use Kontrol's own cheatcodes we must install a [new Solidity library](https://github.com/runtimeverification/kontrol-cheatcodes/) required for symbolic execution. You can install it with Foundry by doing
```
forge install runtimeverification/kontrol-cheatcodes
```

These cheatcodes allow us to generalize the storage of an Ethereum account by making it symbolic or to expect any type of calls, such as a [`delegatecall`](https://www.evm.codes/#f4). An important note on cheatcodes is that, by default, the `infiniteGas()` cheatcode is enabled. This cheatcode abstracts out gas usage by making it infinite, which can remove branches where the execution might fail because you ran out of gas. Enabling infinite gas also speeds up the verificaiton time considerably, since no reasoning about complex gas expressions is performed -which can also entail branching on gas computations.

Even if adding the `infiniteGas()` won't change the symbolic execution behavior on our tests, we'll add it to exemplify how other cheatcodes could be added. Note that you don't really have to modify your code if you're reproducing this tutorial.

To add the `infiniteGas()` cheatcode, after creating the cheatcode file, the test contract `CounterTest` must derive from both `Test` and `KEVMCheats.sol`.

**Note:** Adding custom cheatcodes will prevent us from running the tests with `forge test`, as `forge` will not recognize these cheatcodes.

Now, `Counter.t.sol` should look like this:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Counter.sol";
import "kontrol-cheatcodes/KontrolCheats.sol";

contract CounterTest is Test, KontrolCheats {
   Counter public counter;

   function setUp() public {
       counter = new Counter();
       counter.setNumber(0, false);
   }

   function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

   function testSetNumber(uint256 x, bool inLuck) public {
       kevm.infiniteGas();
       counter.setNumber(x, inLuck);
       assertEq(counter.number(), x);
   }
}
```

Recall that there's no real need to include the `infiniteGas()` in your code, it's only shown here as an example of how to include Kontrol's cheatcodes. A section on how to use each cheat code will be provided in the future.

Let's build a **KEVM** semantic definition for your Foundry project. Our tool compiles the source and test files with `forge build` under the hood, so there's no need to call it explicitly. After compilation, it inspects the artifacts generated by solc and produces **KEVM** helper modules containing information for each Solidity contract found. Each helper module contains productions and rules for ABI properties and bytecode. If you are curious, you can view the `out/kompiled/foundry.k` file. To get started, run the command below:

```sh
kontrol build
```

**Note:** The process should take a minute and may emit some warnings, so donâ€™t worry. Also, remember that during the development, you may need to rebuild the definition in various ways.

If you change the Solidity code, you must re-run `kontrol build` command.

For more information about `kontrol build` and available options, run:

```
kontrol build --help
```

Once you have built the definition, you can run tests symbolically. In this case remember we are expecting the test to **fail**. The proof should fail after running for about 15 minutes.

**Note:** The time it takes to run can vary depending on the machine. If it appears to be stalling, you can add `--verbose` to see what is happening.

To run the tests use the following:

```
kontrol prove --test CounterTest.testSetNumber
```

The `--test CounterTest.testSetNumber` flag is used to specify that only a single proof should be executed. This is useful when there are multiple tests in a test file.

Next, we will cover how to investigate **why** the test failed.

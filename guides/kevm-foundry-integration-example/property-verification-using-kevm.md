# Property Verification using Kontrol

First, we need to modify our test to support symbolic execution. To do this we must import a new Solidity library with cheat codes required for symbolic execution. To do so, create a new file `src/KEVMCheats.sol` and copy over the contents of [this contract](https://github.com/runtimeverification/kontrol/blob/master/src/tests/integration/test-data/foundry/src/KEVMCheats.sol). Now that we have the cheatcode file, the test contract `CounterTest` must derive from both `Test` and `KEVMCheats.sol`.\
\
These cheat codes allow us to generalize the storage of an Ethereum account by making it symbolic or to abstract out gas usage by making it infinite. This can remove branches where the execution might fail because you ran out of gas. To use these cheat codes, we call them at the start of our test as if they were functions imported from a different file. For now, we will make use of the `infiniteGas()` cheat code. We will present more complex examples in a future section.

**Note:** This second change will prevent us from running the tests with `forge`, as `forge` will not recognize these cheat codes.

Now, `Counter.t.sol` should look like this:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Counter.sol";
import "../src/KEVMCheats.sol";

contract CounterTest is Test, KEVMCheats {
   Counter public counter;

   function setUp() public {
       counter = new Counter();
       counter.setNumber(0, false);
   }

   function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

   function testSetNumber(uint256 x, bool inLuck) public {
       kevm.infiniteGas();
       counter.setNumber(x, inLuck);
       assertEq(counter.number(), x);
   }
}
```

Let's build a **KEVM** semantic definition for your Foundry project. Our tool compiles the source and test files with `forge build` under the hood, so there's no need to call it explicitly. After compilation, it inspects the artifacts generated by solc and produces **KEVM** helper modules containing information for each Solidity contract found. Each helper module contains productions and rules for ABI properties and bytecode. If you are curious, you can view the `out/kompiled/foundry.k` file. To get started, run the command below:

```sh
kontrol build
```

**Note:** The process should take a minute and may emit some warnings, so donâ€™t worry. Also, remember that during the development, you may need to rebuild the definition in various ways.

If you change the Solidity code, you must re-run `kontrol build` command again with the `--regen` option.

For more information about `kontrol build` and available options, run:

```
kontrol build --help
```

Once you have built the definition, you can run tests symbolically. In this case remember we are expecting the test to **fail**. The proof should fail after running for about 15 minutes.

**Note:** The time it takes to run can vary depending on the machine. If it appears to be stalling, you can add `--verbose` to see what is happening.

To run the tests use the following:

```
kontrol prove --test CounterTest.testSetNumber
```

The `--test CounterTest.testSetNumber` flag is used to specify that only a single proof should be executed. This is useful when there are multiple tests in a test file.

Next, we will cover how to investigate **why** the test failed.

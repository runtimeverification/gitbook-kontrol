# Property Verification using Kontrol

## Add new code

Open the `Counter.sol` file located at `kontrolexample/src/Counter.sol`. The generated contract `Counter` has a public value named `number` that can be incremented using the method `increment()` , or can be set to a specific value using `setNumber(uint256)`.

Let's modify the code to include a special case in which `setNumber` would not update the `number` value and will throw an error instead. This will cause the symbolic execution of the code to branch.

First, before the `Counter` contract declaration, declare an error by adding `error CoffeeBreak()`. Then, in the `setNumber()` function, add an argument `inLuck` as a `bool`. Lastly, add an `if` statement to define when a coffee break is allowed. We'll specify that a coffee break is permitted if `newNumber` is `0xC0FFEE` and `inLuck` is `true`. In that case, the function reverts and the number is not updated.

With those changes, `Counter.sol` should look something like this:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

error CoffeeBreak();

contract Counter {
    uint256 public number;

    function setNumber(uint256 newNumber, bool inLuck) public {
        number = newNumber;
        if (newNumber == 0xC0FFEE && inLuck == true) {
            revert CoffeeBreak();
        }
    }

    function increment() public {
        number++;
    }
}
```

Let's look at what we have. The `setNumber` method will update our only storage variable with the passed value, _except_ when `newNumber` is `0xC0FFEE` **and** the `bool` variable is `true`.

Now let’s write a test for the contract in `kontrolexample/test/Counter.t.sol`

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0, false);
    }

    function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testSetNumber(uint256 x, bool inLuck) public {
        counter.setNumber(x, inLuck);
        assertEq(counter.number(), x);
    }
}

```

Run the following command to run this test:

```
forge test --match-test testSetNumber
```

This should pass almost every time. Note that the test command will automatically build the project as well. Whether the test passes or not depends on the random inputs generated by `forge`. If `forge` generates the input `x = 0xC0FFEE, inLuck = true`, then the test will fail. Otherwise, it will pass. The point is that there is one case where the property (`setNumber` updates the storage) doesn't hold, but `forge` won't catch it unless it happens to randomly generate this specific input.

Next, we will demonstrate Property Verification using **Kontrol**, and show how it allows us to catch errors like this that `forge` might miss.

## Building the project with Kontrol

Let's build your Foundry project with kontrol. Our tool compiles the source and test files with `forge build` under the hood, so there's no need to call it explicitly. After compilation, it inspects the artifacts generated by `solc` and produces **KEVM** helper modules containing information for each Solidity contract found. Each helper module contains productions and rules for ABI properties and bytecode. If you are curious, you can view the `out/kompiled/foundry.k` file. To get started, run the command below:

```sh
kontrol build
```

{% hint style="warning" %}
The process should take a minute and may emit some warnings, so don’t worry. Also, remember that during the development, you may need to rebuild the definition in various ways.
{% endhint %}

If you change the Solidity code, you must re-run the `kontrol build` command.

For more information about `kontrol build` you can refer to [#kontrol-build](../../cheatsheets/kontrol-cheatsheet.md#kontrol-build "mention") or run:

```
kontrol build --help
```

Once you have built the definition, you can run tests symbolically. In this case remember we are expecting the test to **fail**. The proof should **fail** after running for about three minutes.

{% hint style="info" %}
The time it takes to run can vary depending on the machine. If it appears to be stalling, you can add `--verbose` to see what is happening.
{% endhint %}

To run the tests use the following:

```
kontrol prove --match-test CounterTest.testSetNumber
```

The `--match-test CounterTest.testSetNumber` flag is used to specify that only proofs that match the name `CounterTest.testSetNumber` will execute`. In this case, there is a single proof, but if, for example, you would have passed `CounterTest.test`, then Kontrol woul prove any function in `CounterTest` which is prefixed with `test`. You can find more information on **Kontrol** commands on the [kontrol-cheatsheet.md](../../cheatsheets/kontrol-cheatsheet.md "mention").

{% hint style="info" %}
By default, any gas computation is disabled. To activate, use the `--use-gas` flag for the `prove` command.
{% endhint %}

Now, you can see the status of all the proofs with:

```
kontrol list
```

In the output, you should see two proofs, one for the `setUp` function, and one for the function you just proved!

Now, let's make the proof a bit more general using cheat codes. Since the `Counter` contract is deployed in the `setUp` function, it's storage will be empty when the `testSetNumber` function executes. We can use the `kevm.symbolicStorage(address)` cheat code to make the storage of an address symbolic. With this, we abstract the storage, considering it could have any value instead of the ones assigned during the initialization.

In order to add the cheat code, we need to include the `kontrol-cheatcode` library and inherit the contract.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Counter.sol";
import "kontrol-cheatcodes/KontrolCheats.sol";

contract CounterTest is Test,KontrolCheats {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0, false);
    }

    function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testSetNumber(uint256 x, bool inLuck) public {
        kevm.symbolicStorage(address(counter));
        counter.setNumber(x, inLuck);
        assertEq(counter.number(), x);
    }
}
```

To rerun the proof with these changes, you have to run `build` and `prove` again. The output of the proof should be the same. The difference can be noticed using the kontrol kcfg visualizer, used to analyze the state of the vm at different points (nodes) in the symbolic execution. The difference should be that now, the storage of the deployed `Counter` test, is symbolic instead of an empty Map.

Next, we will cover how to investigate **why** the test failed.

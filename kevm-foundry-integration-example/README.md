---
description: How to run property tests with the KEVM Foundry Integration
---

# KEVM Foundry Integration Example

## Create a new Foundry project

```
forge init --no-git kevmexample
```

This command creates a new Foundry project that can be used as an example. The project's structure is presented in detail in the [Foundry book](https://book.getfoundry.sh/projects/project-layout). We can only fuzz parametric tests for now because the project is not configured to support symbolic execution yet. We will cover this topic later in [property-verification-using-kevm.md](property-verification-using-kevm.md "mention"). After creating the project, you can start editing the code.

## Add new code

Open the `Counter.sol` file located at `kevmexample/src/Counter.sol`. The generated contract `Counter` has a public value named `number` that can be incremented using the method `increment()` , or can be set to a specific value using `setNumber(uint256)` .

Let's modify the code to include a special case in which `setNumber` would not update the `number` value. First, add a line `error CoffeeBreak()`. Then, in the `setNumber()` function, add an argument `inLuck` as a `bool`. Lastly, add an `if` statement to define when a coffee break is allowed. We'll say that we are going to have a coffee break if `newNumber` is `0xC0FFEE` and `inLuck` is `true`. In that case the function reverts and the number is not updated.

With those changes, `Counter.sol` should look something like this:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

error CoffeeBreak();

contract Counter {
   uint256 public number;

   function setNumber(uint256 newNumber, bool inLuck) public {
       number = newNumber;
       if (newNumber == 0xC0FFEE && inLuck == true) {
           revert CoffeeBreak();
       }
   }
    
   function increment() public {
        number++;
    }
}
```

Let's look at what we have. The `setNumber` method will update our only storage variable with the passed value, _except_ when `newNumber` is `0xC0FFEE` **and** the `bool` variable is `true`.

Now letâ€™s write a test for the contract in `kevmexample/test/Counter.t.sol`

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Counter.sol";

contract CounterTest is Test {
   Counter public counter;

   function setUp() public {
       counter = new Counter();
       counter.setNumber(0, false);
   }
   
   function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

   function testSetNumber(uint256 x, bool inLuck) public {
       counter.setNumber(x, inLuck);
       assertEq(counter.number(), x);
   }
}

```

Run the following command to run this test:

```
forge test --match-test testSetNumber
```

This should pass almost every time. Note that the test command will automatically build the project as well. Whether the test passes or not depends on the random inputs generated by `forge`. If `forge` generates the input `x = 0xC0FFEE, inLuck = true`, then the test will fail. Otherwise, it will pass. The point is that there is one case where the property (`setNumber` updates the storage) doesn't hold, but `forge` won't catch it unless it happens to randomly generate this specific input.

Next, we will demonstrate Property Verification using **KEVM**, and show how it allows us to catch errors like this that `forge` might miss.
